/*commanlinetool for segmentation */#include <fstream.h>#include <stdio.h>#include <time.h>#include "../datalib/vector.h"#include "../datalib/volume.h"#include "../mathlib/statistic.h"#include "../mathlib/transform.h"#include "../mathlib/moments.h"#include "../errorcode.h"#include "../datalib/datacube.h"#include "../datalib/cfddatacube.h"#include "../datalib/testcubes.h"#include "../reconstructionlib/reconstruction.h"#include "../mathlib/nld.h"#include "command_line_parser.h"int presentstep;intcallBackFunction(int percentage){    cout << endl << "*******************" << endl;    cout << "Present step: " ;    switch (presentstep)    {	case 1: cout << "First Filtering (1 of 3)" << endl;break;	case 2: cout << "Segmentation (2 of 3)" << endl;break;	case 3: cout << "Second Filtering (3 of 3)" << endl;break;    };        cout << percentage << "% of this step done." << endl;    return 0;}int filter(DataCube *dC){    FilterOptions filterOptions;    MultiCompartmentList *multiCompList= new MultiCompartmentList(dC,callBackFunction);    //Create hierachy    int i=0, maxsize=200;    for (i=0;(i<10 && !(maxsize<100) );i++)	maxsize=multiCompList->createNextLevelSmart();    //Run filter    int lastErrorCode=multiCompList->filter(filterOptions);    if (lastErrorCode) return lastErrorCode;    delete multiCompList;    //finish    return 0;}using namespace std;using namespace pramodx;intmain(int argc, char **argv){    DataCube cube(3);    DataCube *segmented;	char inputfile[160];	char outputfile[160];	char buffer[160];	Vector<int> size(3);	Vector<double> d(3);	size[1]=0;	size[3]=0;	size[3]=0;	d[1]=1.0;d[2]=1.0;d[3]=1.0;        int invert=0;        command_line_parser parser(argc, argv);    if (argc<2)    {        cout << "Usage: preparedata inputfilename.tif outputfilename.tif" << endl;        return 0;    };    for (int i=0;i<parser.get_n_options();i++)    {        option o=parser.get_option(i);        if (strcmp(o.get_option(),"h")==0 || parser.get_n_filenames()==0)        {            cout << "Usage: preparedata inputfilename.tif outputfilename.tif" << endl;            cout << "Optional: -dx:(spaceingx) -dy:(spaceingy) -dz:(spaceingz)" << endl;            return 0;        };                if (strcmp(o.get_option(),"dx")==0)        {            float help;            if (sscanf (o.get_value(),"%f",&(help))==EOF) continue;            d[1]=help;            cout << "dx=" << d[1] << endl;        };        if (strcmp(o.get_option(),"dy")==0)        {            float help;            if (sscanf (o.get_value(),"%f",&(help))==EOF) continue;            d[2]=help;            cout << "dy=" << d[2] << endl;        };        if (strcmp(o.get_option(),"dz")==0)        {            float help;            if (sscanf (o.get_value(),"%f",&(help))==EOF) continue;            d[3]=help;            cout << "dz=" << d[3] << endl;        };            };sprintf(inputfile,parser.get_filename(0));printf("Inputfile:");printf(inputfile);printf("\n");sprintf(outputfile,parser.get_filename(1));printf("Outputfile:");printf(outputfile);printf("\n");int res=cube.ReadFromTIFF(inputfile);if (res!=0 && res!=NO_SPACEINGS_TAGS) {    cout << "Error durring read!" << endl;    return 1;};cube.SetSpaceing(d);segmented=new DataCube(cube);presentstep=1;//filter1cout << "_______________________________________" << endl;cout << "Start Filtering 1:" << endl;if (filter(&cube)) {    cout << "Error durring filtering!" << endl;    exit(1);};cout << "done" << endl;cout << "_______________________________________" << endl << endl;//segmentation1presentstep=2;    Segmentation segmentation(&cube,segmented,callBackFunction);    double absoluteLowThreshold=.01;    double absoluteHighThreshold=0.3;    double epsilon=0.01;    segmentation.SegmentateByStructuralThresholding(absoluteLowThreshold,absoluteHighThreshold, epsilon);//filter2presentstep=3;cout << "_______________________________________" << endl;cout << "Start Filtering 2:" << endl;if (filter(&cube)) {    cout << "Error durring filtering!" << endl;    exit(1);};cout << "done" << endl;cout << "_______________________________________" << endl << endl;if (segmented->WriteToTIFF(outputfile)) {cout << "Can not write tif file" << endl;};sprintf(buffer,"%s.dx",outputfile);if (segmented->writeDataForDX(outputfile)) {cout << "Can not write dx file" << endl;};cout << "Finished processing" << endl;return 0;}